# Explaining the design approach to CircleCI Configuration

## Core Characteristics of CircleCI Build Configuration
1. **Deterministic:** Every build should behave the same way given the same inputs. This prevents things from changing on you that you can't control, and it prevents CircleCI from having to make and then carry assumptions about how you want to run your builds.
1. **Config as Data:** We use YAML because it provides a way to author a data structure with a reasonable balance between syntactic weight and expressiveness. Having configuration be data rather than a programming language allows easy and reliable tooling for doing config syntax and schema validation, various static analysis and data tranformations that occur during the processing of your builds, and automated documentation with first-class metadata.
1. **Declarative of Build Behaviors:** The semantics of CircleCI config revolve around the core domain model of build execution inside our platform.  The core structure is driven by workflows that invoke and coordinate jobs that express a set of steps to run and the execution environment in which to run them. Our configuration code is intrinsically meta to your build process. We want to let you focus on what your code is going to do inside the runtime and get out of your way as much possible. Using a declarative syntax allows to give you an expressive set of primitives without making you learn much, if anything, about how our internal systems work or learn some new programming language.

## Configuration lifecycle
1. **Retrieval:** Build configuration you write is retrieved from your git repository when CircleCI receives webhooks from your version control provider (eg: GitHub) or can be passed in as part of an API call triggering a build. 
2. **Processing:** Build configuration goes through a processing step prior to hitting the workflows and job execution layers of CircleCI. All invoked commands, jobs, and other structural elements, along with any parameters passed in this invocations, are resolved during this configuration processing step. One major implication is that configuration processing does not have access to your runtime environment or your environment variables and other sensitive information.
3. **Coordination:** Workflows enforce the rules of when to run specific jobs and keep track of the state of those jobs.
4. **Execution:** The steps of your jobs as executed in the executor you specified, which is provisioned just for running your job and discarded after your job completes. This is the stage at which your environment variables and other build data is injected.

## Design choices made in Orbs
1. **Stick with YAML:** We considered providing a DSL in a programming language like javascript or python to build the data structures of configuration dynamnically. We chose to first build a YAML-based packaging mechanism because:
    * Our customers and employees already know it, so itâ€™s adds the least friction and cognitive load to adopt.
    * It is a widely adopted data format that allow us to provide a deterministic and declarative DSL. No other data format was deemed better enough to switch.
    * Using a data format instead of a programming language means our configuration can more easily be self-documenting and statically processed.
1. **Transparency:** If you can execute an orb you can see the source of that orb. Orb is more akin to configuration you would otherwise copy and paste than it is like a piece of your core software - Orbs are part of your build process, so you should be able to see what they do if can execute them.
1. **First-class Metadata:** We allow a `description` key as part of the structure of orbs, so it's easier to generate documentation or read through the code without having extra-structural comments.
1. **Semantic Versioning and Locking:** We want orb users to never have things changes out from under them but also allow orb authors to continue adding features and fixes to orbs. We choose to enforce a strict format for [semver](https://semver.org/) on all published revisions. When importing we allow an orb user to lock a specific revision or choose to use the latest and assume the risk of breakage.
1. **Register-time Dependency Resolution:** If an orb imports other orbs we will resolve and lock those dependencies at the time the revision that orb is added to the registry. If you import an orb "foo/bar" into your orb's revision at the "latest" of foo/bar, we will pull whatever the latest is of "foo/bar" at the time you register your orb and lock that to your revision. This means that if "foo/bar" subsequently publishes a new revision you would need to push a new revision of your orb to pick that up.
1. **One registry per CircleCI installation:** Orbs are specific to running CircleCI builds, so we decided to avoid the complexities and security surface area of having arbitrary registries. All orbs used in a CirlceCI build must be in the registry of the installation on which your build runs. 
1. **All orbs live in a namespace:** All orbs live in exactly one namespace. There is no "empty" namespace, nor are reserving a special default like "_" for our own orbs or for "official" orbs. We are likely to introduce a Certified Orbs program or similar in the future, but that will be first-class metadata on the orb rather than implied by inclusion in a special namespace.
1. **Revisions are immutable:** To prevent mysterious changes cropping up in the builds of those who use orbs, we do not allow changes to an orb revision once it has gone live.
